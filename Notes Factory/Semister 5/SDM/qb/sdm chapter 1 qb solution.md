

### **Q.1 Define the term Software and list types of software.** (2 Marks)

* **Software** is a collection of instructions, data, or computer programs that are used to run machines and carry out particular activities.
* It is the opposite of hardware, which refers to a computer's physical components.

* **Types of software:**

  1. **System Software** – It manages hardware and system resources (e.g., Windows OS).
  2. **Application Software** – It helps users perform specific tasks (e.g., MS Word).

***
### **Q.2 Define the term Software Engineering. Explain its need in modern software development.** (4 Marks)

* **Software Engineering** is the process of designing, developing, testing, and maintaining software in a systematic and disciplined manner to ensure high-quality, reliable, and maintainable software.
* It uses various tools, techniques, and methodologies such as requirement analysis, design, testing, and maintenance to manage the software development lifecycle.


**Need in Modern Software Development:**

* Ensures the software is **accurate, reliable**, and completed **on time and within budget**.
* Makes it easier to **handle big and complex projects** through proper planning.
* Improves the **quality and ease of fixing or updating** the software.
* Allows **faster development** using modern tools and technologies.
* Helps reduce mistakes and ensures the software meets the **user’s needs**.



***
### Q.3 Explain any four phases of the Software Development Life Cycle (SDLC) with a neat diagram. (6 marks)


![image](.attachments/6f2212a14cfe73f1eae21326f9ddbd7ef766b5d9.png) 


 1. **Defining Requirements**

* After analyzing the needs, the next step is to document the software requirements clearly.
* This is done using an **SRS (Software Requirement Specification)** document.
* It includes all features and expectations agreed upon by the stakeholders.

 2. **Designing the Software**

* In this phase, the system architecture and design are prepared based on the requirements.
* It includes the selection of technologies, database design, and system layout.
* It serves as a blueprint for developers to follow.

 3. **Developing the Project**

* Actual coding starts in this phase using the selected programming languages and tools.
* Developers follow coding standards and write the code based on the design.
* Tools like compilers, interpreters, and debuggers are used.

 4. **Testing**

* After development, the software is tested to check if it meets all requirements.
* Various testing methods like **unit testing, integration testing, and system testing** are used.
* This helps find and fix bugs before the final release.


***


### **Q.4 Write the need of SDLC in Software Engineering.** (4 Marks)

**Need of SDLC:**

-   The development team must choose and follow a suitable life cycle model for proper planning.
    
-   Without it, software development becomes unstructured and undisciplined.
    
-   Team members must clearly understand **what to do and when to do it** to avoid confusion.
    
-   Otherwise, if one member starts coding, another writes test cases, and another begins design without coordination, it leads to **chaos and project failure**.
    
-   **This same situation can be avoided by using SDLC**, and in this case, a model like **Waterfall** ensures the team follows a proper sequence — from requirements to design, coding, and testing — for smooth and successful development.
***
###  **Q.5 Role of SDLC and list any four SDLC models** _(4 Marks)_



The Software Development Life Cycle (SDLC) plays a crucial role in guiding the entire software development process in a structured and organized manner.  
It breaks down the project into defined phases such as requirement gathering, design, development, testing, and deployment.  
By following SDLC, development teams can maintain quality, manage time and budget effectively, reduce risks, and ensure the final product meets the required standards and user expectations.

**Any Four SDLC Models:**

1.  Waterfall Model
    
2.  Iterative Model
    
3.  Incremental Model
    
4.  Prototype Model

***
### Q.6 Explain the phases of the Waterfall Model with a neat diagram. (6 marks)
> [!attention] ignore the circle thingy in diagram 

![image](.attachments/3c02363befd24e6107ee7e830b85edaac75b4535.png) 

 🔹**1. Requirement Analysis:**  
This is the first stage where the team tries to understand what the customer actually needs from the software. All the important functions, features, and performance points are discussed and written down clearly in the form of a **Software Requirement Specification (SRS)** document. This document acts as a reference for the whole project.

🔹 **2. Design Phase:**  
Once the requirements are clear, the next step is to plan how the software will work. This includes deciding the overall structure, database design, and interface layout. All design ideas and technical decisions are documented in the **Software Design Document (SDD)**, which helps developers during coding.

🔹 **3. Development Phase:**  
In this phase, the actual coding work starts. Developers write the program based on the design using suitable programming languages. The software is usually created in parts or modules, and **unit testing** is done to check if each part is working fine on its own.

🔹 **4. Testing Phase:**  
After the development is completed, the full software is tested to make sure it meets the requirements. Testers perform different tests like integration testing and system testing to find bugs or issues. If any problem is found, it’s reported and fixed before the next phase.

🔹 **5. Deployment and Maintenance:**  
Once everything is working fine, the software is given to the client or released in the market. But even after deployment, there may be small issues that come up. The team releases **patches or updates** to fix them. Also, if needed, new features can be added later as part of maintenance.
***
###  Q.7 Explain the Waterfall Model in detail with a diagram. Write any two advantages and disadvantages. (8 marks)
> [!attention] ignore the circle thingy in diagram 

![image](.attachments/3c02363befd24e6107ee7e830b85edaac75b4535.png) 
**Waterfall Model**

The Waterfall Model is one of the oldest and most widely used software development life cycle (SDLC) models. Introduced by Winston Royce in 1970, it follows a linear and step-by-step process where each phase flows into the next—like water flowing down a waterfall. It is also known as the Linear Sequential Model. The phases include Requirement Analysis, Design, Development, Testing, Deployment, and Maintenance. Each phase must be fully completed before moving on to the next, and the output of one phase becomes the input for the next. This approach ensures structured development and clear documentation at every step.


**When to Use the Waterfall Model**

This model is most suitable when the project requirements are clearly defined and unlikely to change during the development process. It works well for small or simple projects where the scope is fixed, and the development tools and resources are already planned. It is especially useful in government or formal environments where detailed documentation and planning are essential.


**Advantages of Waterfall Model**

-   Easy to understand and use, especially for beginners.
    
-   Each phase is well-documented with clear goals.
    
-   Works well for small-scale projects with stable requirements.
    


**Disadvantages of Waterfall Model**

-   Not ideal for projects where requirements may evolve.
    
-   Once a phase is completed, it's hard to go back and make changes.
    
-   The final product is only seen at the end, so early feedback is limited.
    



**Example – Government Exam Portal**

For example, when developing an online exam portal for a government exam like SSC or UPSC, all features—such as registration, admit card generation, and online testing—are predefined. The project has strict deadlines and no room for major changes during development. Using the Waterfall Model here ensures everything is planned, built, and tested in order, with no surprises before launch. Any improvements or fixes are handled later during the maintenance phase.

***
### Q.8 Describe the working of the Waterfall Model. List any three advantages and three disadvantages. (6 marks)
> [!attention] ignore the circle thingy in diagram 

![image](.attachments/3c02363befd24e6107ee7e830b85edaac75b4535.png) 

**Working of Waterfall Model:**

The Waterfall Model is a linear and structured approach to software development where each phase is completed before the next one begins. The process starts with **requirement analysis**, where the software’s goals and functions are clearly defined and documented. After that, in the **design phase**, these requirements are converted into a detailed system plan.

Next, in the **development phase**, actual coding is done based on the design. After development, the software goes through **testing** to identify and fix any bugs. Once the testing is successful, the system is **deployed** for use. The final stage is **maintenance**, where updates or patches are made after release. This model ensures that every phase is completed properly before moving to the next, and the output of one becomes the input for the next.


**Advantages:**

1.  Simple and easy to use and understand.
    
2.  Each phase has clear deliverables and documentation.
    
3.  Ideal for smaller projects with fixed requirements.
    



**Disadvantages:**

1.  Not suitable for changing or unclear requirements.
    
2.  Difficult to go back to a previous phase once it's completed.
    
3.  No working software is produced until late in the cycle.
***
### Q.9 When is the Waterfall Model preferred in software development? Give examples of suitable projects. (4 marks)
The Waterfall Model is preferred when the **project requirements are well-defined, fixed, and not expected to change** during development. It works best for **simple or medium-scale projects** where the **development process can follow a clear linear sequence** — from requirement gathering to maintenance — without frequent changes or feedback loops.

 Examples of Suitable Projects:

1.  **Government Exam Portal** – All modules like registration, admit card, and result processing are planned in advance with fixed deadlines.
    
2.  **Library Management System** – Book issuing, return, and fine calculation follow standard, unchanging logic.
    
3.  **Payroll Processing System** – The system works based on fixed tax and salary rules that rarely change during development.
***
### Q.10 Draw and Explain iterative model (6 marks)
![image](.attachments/bff42881fd2b91c2f5605ade5fa73ba25d309902.jpeg) 
The **Iterative Model** is an approach to software development where the system is built incrementally through repeated cycles, or _iterations_. Instead of trying to get everything perfect in the first attempt, the software is developed step-by-step — improving and adding features in each version.

-   The SDLC process starts with **initial requirement gathering and analysis**.
    
-   A **basic version of the software is developed** with available requirements.
    
-   Based on **feedback or additional requirements**, the next version is created by refining or adding features.
    
-   This **cycle repeats**, creating multiple versions until the software meets the final expectations.
    
-   Once finalized, the product is **deployed** and moves to the maintenance phase.
    

Each iteration goes through the common SDLC phases: planning, design, development, testing, and evaluation.
***
### Q.11 When is the Iterative model preferred in software development? Explain any two advantages and disadvantages. (6 marks)

**When to Use Iterative Model:**

The Iterative Model is preferred when:

-   The project is **large in size** and requirements may evolve during development.
    
-   There is a **need to accommodate changes or enhancements** in the future.
    
-   The **development team is learning a new technology** while working on the project.
    
-   The project includes **high-risk features or goals** that are not clearly defined in the beginning.
    
-   **User feedback is important**, and the product needs to improve through multiple versions.
    



**Advantages of Iterative Model:**

1.  **Easier testing and debugging:** Since development happens in small cycles, errors are identified early and fixed quickly.
    
2.  **Flexible for changing needs:** New requirements or modifications can be added during iterations without restarting the project.
    
3.  **Risk handling:** High-risk features can be addressed in early iterations, reducing uncertainty later.
    



**Disadvantages of Iterative Model:**

1.  **Not ideal for small projects:** Iterative development may be overkill for simpler or short-term tasks.
    
2.  **Resource intensive:** More effort is needed to manage multiple iterations, which may require more developers or tools.
    
3.  **Uncertain deadlines and costs:** Changing requirements in each iteration can lead to delays and increased budget.
***
### Q.12 Explain the Iterative model in detail with a diagram. Write any two advantages and disadvantages. (8 marks)

![image](.attachments/bff42881fd2b91c2f5605ade5fa73ba25d309902.jpeg) 
 **Iterative Model Explanation:**

The Iterative Model is a software development process where the software is built and improved step-by-step through repeated cycles called iterations. Each cycle includes requirement gathering, design, development, and testing. After the first version of the software is developed, it is evaluated. Based on feedback and changes, a new version is created in the next cycle.

This process continues until the complete system is developed. It allows developers to make improvements and add new features based on real-time feedback, which helps handle changing requirements and reduces risks early in the project.



 **Advantages of Iterative Model:**

1.  Testing and debugging during smaller iteration is easy.
    
2.  A parallel development can be planned.
    
3.  It is easily acceptable to ever-changing needs of the project.
    



**Disadvantages of Iterative Model:**

1.  It is not suitable for smaller projects.
    
2.  More resources may be required.
    
3.  Design can be changed again and again because of imperfect requirements.
    

 **Real-World Example:**

Suppose a team is building an **educational learning portal** where features like user login, quizzes, video lectures, and chat support are added over time. Instead of planning everything from the start, they build one feature, get feedback, improve it, and then move to the next. This makes the Iterative Model suitable because changes and improvements are expected at each stage.









***
###  Q.13 Draw and Explain Incremental model (6 marks)

![Incremental Model in SDLC: Use, Advantage & Disadvantage](https://www.guru99.com/images/6-2015/052615_1049_WhatisIncre2.png)



The **Incremental Model** is a software development approach where the project is broken down into small, manageable modules. Each module goes through its own **requirement analysis, design, development, and testing phases** independently. These modules are developed **incrementally**—meaning, each new version of the software adds additional features or functions to the previously developed one.

Initially, only a basic version of the software is developed. Then, in **subsequent increments**, more features are added until the **final complete system is delivered**. This model is useful for projects where the **core requirements are known**, but additional features may evolve over time.

 **Example Scenario:**

An example could be building a **banking app** where the first increment delivers login and balance check, the second adds fund transfer, and the third adds bill payment. Each increment adds a working feature without disrupting previously built modules.

***
### Q.14 When is the Incremental model preferred in software development? Explain any two advantages and disadvantages. (6 marks)

 **When to Use the Incremental Model:**

The Incremental Model is preferred when the software requirements are mostly clear and understood from the beginning. It is useful when the client demands an early working version of the product, especially if some features are more important and can be delivered first. This model also suits long-duration projects where development happens in stages. It is ideal when the development team is not fully skilled or is still adapting to new technologies. In many cases, it is used in web applications or product-based companies where updates are frequent and feature-wise delivery is possible.

 **Advantages of Incremental Model:**

1.  The client gets important functionality delivered early.
    
2.  Errors are easier to recognize and fix at each stage.
    
3.  Easier to test, debug, and manage risks during each increment.
    

**Disadvantages of Incremental Model:**

1.  Requires clearly defined module interfaces from the beginning.
    
2.  Needs good planning and coordination due to continuous iterations.
    
3.  System architecture problems may arise since not all requirements are gathered upfront.



**Example:**  
A railway ticket booking system where the first version allows basic ticket search and booking. Later increments add seat selection, payment gateway integration, and SMS notifications.
***
### Q.15 Explain the Incremental model in detail with a diagram. Write any two advantages and disadvantages. (8 marks)

![Incremental Model in SDLC: Use, Advantage & Disadvantage](https://www.guru99.com/images/6-2015/052615_1049_WhatisIncre2.png)


The **Incremental Model** is a software development process where the overall system is built **in pieces (increments)**. Each increment adds new functionality or features. At the beginning, only basic requirements are implemented. As the project progresses, more features are developed and integrated until the full product is complete.

The process follows multiple **iterations**, and each iteration goes through **Requirement gathering, Design, Development, and Testing** phases. After every increment, the working software is delivered to the client. This model is especially useful when requirements are well understood in the beginning but may evolve later on.

 **Advantages**

1.  Important features are delivered to the client early in the process.
    
2.  Easier to test and debug as smaller modules are handled at a time.
    
3.  Flexible and less costly to change scope or requirements.
    

 **Disadvantages**

1.  Requires well-defined module boundaries and good architecture upfront.
    
2.  A skilled team and proper planning are necessary for smooth iteration handling.
    
3.  Continuous integration of increments can lead to complexity if not managed properly.
    

**Example**

A railway ticket booking system where the first release allows basic ticket search and booking. Later increments add features like seat selection, payment integration, and real-time SMS alerts.
***
###  Q.16 Draw and Explain Prototype model (6 marks)

![image](.attachments/ca72007d302f2e449b2fa0e426e963efaace33cb.png) 

The Prototype Model is used when the customer’s requirements are not clearly understood. Instead of developing the final product immediately, a basic working model (prototype) of the software is created to demonstrate its functionality.

This model involves an **iterative process** where developers build a prototype, present it to the user, and improve it based on feedback. Once the user is satisfied with the prototype, the actual software is developed.

This approach helps in **clarifying vague requirements** and reduces chances of rework in later stages.



 **Example Scenario:**

A client wants a **custom event management app**, but isn't sure how the UI or booking flow should work. Developers create a prototype with dummy screens and sample actions. The client reviews it, suggests changes, and once finalized, the actual system is developed.

***
### Q.17 When is the Prototype model preferred in software development? Explain any two advantages and disadvantages. (6 marks)

 **When to Use:**

The Prototype Model is preferred when the **requirements of the system are unclear or incomplete** at the beginning of the project. It is especially useful when clients are not sure about what they want, or when the product involves a lot of user interaction. This model is also suitable for **complex and innovative projects** where trial-and-error helps refine features, layout, and overall system flow.

**Advantages:**

1.  Customers are actively involved in development, which increases satisfaction and ensures the product meets their needs.
    
2.  Errors and misunderstandings can be identified early, saving time and effort later.
    
3.  Design is flexible and can be modified easily based on feedback.
    

 **Disadvantages:**

1.  Development may take more time and cost due to continuous feedback and changes.
    
2.  Frequent changes can disturb the development rhythm and delay the final product.
    
3.  Documentation is often poor, as requirements change frequently and are hard to track.
    

 **Example Scenario:**

A startup wants to build a **new food delivery app**, but isn’t clear on how the interface should look or what features users will prefer. A prototype helps the team get feedback and make changes before starting actual development.
***
### Q.18 Explain the Prototype model in detail with a diagram. Write any two advantages and disadvantages. (8 marks)


![image](.attachments/ca72007d302f2e449b2fa0e426e963efaace33cb.png)


The **Prototype Model** is a software development method where an early, rough version of the system is built first to understand user requirements more clearly. It acts like a sample or mock version of the final product and is improved in multiple iterations based on user feedback. Once all major requirements are confirmed, the actual development begins using those finalized expectations.

This approach is ideal when requirements are unclear or expected to change, and it allows clients to interact with the system early in the process.


**Advantages:**

1.  Clients can see the system early, which helps clarify expectations.
    
2.  Requirements are better understood through feedback on the prototype.
    
3.  Reduces chances of major changes late in the development phase.
    

**Disadvantages:**

1.  Too many changes in the prototype can delay actual development.
    
2.  It may lead to poor documentation due to frequent updates.
    
3.  Can become expensive if many prototypes are made or discarded.
    


**Example Case:**  
A startup wants to build an AI-powered job recommendation app but isn't sure about the UI or core features. The developers first build a prototype with sample screens and logic. After user feedback, they refine the design and finalize the real product flow.
***
### Q.19 Draw and Explain Spiral model (6 marks)


The **Spiral Model**, proposed by _Barry Boehm in 1986_, is a **risk-driven process model** used in software development. It combines the strengths of the **Waterfall**, **Prototyping**, and **Iterative** models. The software is developed in repeated cycles or "spirals", where each spiral results in a more complete version of the software.

Each spiral (cycle) is divided into **four major phases**:

![image](.attachments/71861e4d9b742cfde68e8b935a90c32485abe87a.png) 

1.  **Planning** – Define objectives, constraints, and alternatives.
    
2.  **Risk Analysis** – Identify potential risks and find solutions.
    
3.  **Engineering & Execution** – Actual development, coding, and testing.
    
4.  **Customer Evaluation** – Client reviews the current version and gives feedback.
    

This cycle is repeated with refinements until the final product is developed.

 **Example Case:**

Suppose a company is building a **new operating system**. Due to complexity, changing needs, and potential technical risks, the Spiral Model suits well. Each version of the OS is released in iterations, and risks like hardware compatibility or security flaws are addressed early in each spiral.



***
### Q.20 When is the Spiral model preferred in software development? Explain any two advantages and disadvantages. (6 marks)

The **Spiral Model** is preferred when the project is **large-scale, complex, and involves high risks**. It is suitable when requirements are not well understood at the beginning, and the project demands **frequent evaluation and adaptation**. This model fits projects that need **continuous customer involvement**, regular feedback, and **prototyping for better understanding**.

It is especially used when:

-   There is a need for **frequent risk assessment**.
    
-   The budget is high and the timeline is long.
    
-   Changes may occur at any stage due to evolving requirements or economic shifts.
    
**Advantages of Spiral Model:**

1.  Encourages **early identification and resolution of risks**, which reduces failure chances.
    
2.  It supports **customer feedback** and changing requirements during development.
    
3.  Suitable for **large and mission-critical projects** where constant evolution is needed.
    
 **Disadvantages of Spiral Model:**

1.  Requires **skilled experts for risk analysis**, which can be difficult to manage.
    
2.  It may become **expensive and time-consuming** for smaller projects.
    
3.  The process can be **complex and hard to manage** due to its iterative and cyclic nature.
    
 **Example Case:**

A **defense system software** project with high-security needs and unclear initial requirements can follow the Spiral Model. Its complexity, criticality, and risks make the model a perfect fit.
***
### Q.21 Explain the Spiral model in detail with a diagram. Write any two advantages and disadvantages. (8 marks)

The **Spiral Model** is a **risk-based software development approach** that combines elements of the **Waterfall**, **Iterative**, and **Prototyping** models. It is mainly used when the project is large, complex, and requirements are unclear or expected to change. The development progresses in **repeating spirals**, where each spiral adds more features and refinements based on feedback and risk evaluation.


![image](.attachments/71861e4d9b742cfde68e8b935a90c32485abe87a.png) 

Each spiral follows four key phases:

1.  **Planning** – Set goals, identify alternatives, and note constraints.
    
2.  **Risk Analysis** – Detect risks and explore possible solutions.
    
3.  **Engineering** – Perform development and testing of the product.
    
4.  **Customer Evaluation** – Take feedback from the client for improvements.
    

This loop continues until the final version of the software is complete.

 **Advantages:**

1.  Supports **risk analysis at every stage**, which reduces the chances of major failure.
    
2.  Allows **changes in requirements** even in later stages of development.
    
3.  Helps deliver **prototypes early**, improving communication with the client.
    

 **Disadvantages:**

1.  Needs **experienced project managers** and skilled risk analysts.
    
2.  **Not suitable for small or low-budget projects** due to cost and complexity.
    
3.  Can be **difficult to manage** as it may involve many cycles and documentation.
    
 **Example Case:**
A **defense system software** project with high-security needs and unclear initial requirements can follow the Spiral Model. Its complexity, criticality, and risks make the model a perfect fit.
***
### Q.22 Problem statements based on SDLC models (each for 1 mark) (2/4 marks)

### Problem Statements based on SDLC Models (2 Marks)


> [!abstract] Key Words for SDLC Model Identification
> 
> -   **Waterfall:** Look for keywords related to a rigid, sequential process.
>     
>     -   **Keywords:** **"well-defined and fixed upfront,"** **"step-by-step plan,"** **"without overlapping phases,"** **"strict sequence,"** "clearly written specifications."
>         
> -   **Iterative:** Look for keywords related to cycles of refinement and improvement. The focus is on a single product that gets better over time.
>     
>     -   **Keywords:** **"build-feedback-improve cycles,"** "iterative loops," "refining features," "multiple versions" (where each version is a refinement of the last), "explore and refine."
>         
> -   **Incremental:** Look for keywords related to building and delivering functional parts of the product, one after the other.
>     
>     -   **Keywords:** **"feature by feature,"** "delivers working code frequently," "release each module separately," "working parts," "builds on the previous one."
>         
> -   **Agile:** Look for keywords related to speed, flexibility, and customer collaboration.
>     
>     -   **Keywords:** **"short sprints,"** **"daily meetings,"** **"time-boxed iterations,"** "constant feedback," "adapt to changing needs," "early feedback."
>         
> -   **Spiral:** Look for keywords related to risk management. It's the only model that explicitly mentions risk.
>     
>     -   **Keywords:** **"continuous risk analysis,"** **"any failure is unacceptable,"** "risks must be evaluated," "critical goals."
>         
> -   **Prototype:** Look for keywords related to building a preliminary version to clarify requirements.
>     
>     -   **Keywords:** **"working demo,"** **"visual working demo,"** **"basic mock-up,"** "rough prototype," "mock system," "unclear about the exact UI."


> [!abstract] Answers mentioned in end 
> Excercise



1.  The team is building a complex AI system where the requirements are constantly evolving, and the customer needs to see working code and give feedback every **two weeks**.
    
2.  A government defense project has clearly defined and unchanging requirements, and the process must be followed in a **strict, sequential order** without deviation.
    
3.  A mobile app is to be released with core functionality first, followed by separate, planned **feature additions** like social media integration and user profiles in later releases.
    
4.  Developers are unsure about the client's final design for a new e-commerce website, so they first create a basic, non-functional **visual mock-up** for the client's approval.
    
5.  A large-scale project for a medical device requires extensive **risk analysis** at every stage, as a system failure could be catastrophic.
    
6.  The team works in **short, time-boxed cycles**, where each cycle delivers an improved and more refined version of the software.
    
7.  A software system is built in modules, with each **module being developed and delivered** to the client as soon as it is completed.
    
8.  The client has a general idea for an educational app but needs to first interact with a **working demo** to help finalize the features and user experience.
    
9.  A high-risk project involves developing a new flight control system. The team needs to identify and **mitigate risks** before committing to development for each phase.
    
10.  The project manager wants to follow a **rigid, step-by-step plan** for a well-understood banking application, with a single delivery at the end.
     
11.  A small startup is building a new social platform and needs to get **constant feedback** from users to pivot and add new features as they are requested.
     
12.  The team first builds a **rough version** of the software to get client feedback on the overall concept before investing time in building the full system.
     
13.  A large business management software is being developed, where new features are **added in phases**, each new release containing a new set of capabilities.
     
14.  An application is developed through a series of **development-and-testing cycles**, with each cycle adding more functionality and improving the product.
     
15.  The team is developing software for a critical infrastructure system. Due to the high-stakes nature, they must perform **risk management** and reviews before moving from one phase to the next.
     
16.  The team needs to release a minimum viable product (MVP) with only essential features to meet a tight deadline, with more features to be **delivered incrementally** later.
     
17.  A team of developers and a client are collaborating closely, with daily check-ins and frequent releases to **adapt to changing requirements**.
     
18.  The project is a new operating system that will be developed in **multiple versions**, where each subsequent version is a more complete and feature-rich refinement of the previous one.
     
19.  A team is tasked with building a web application. Due to the client's **uncertainty about the final design**, they first create a **throwaway prototype** to explore options.
     
20.  A large corporation needs a new payroll system with **stable, well-defined requirements**. The team is to progress through distinct stages of design, coding, testing, and deployment.
 > [!check] Answers with Justifications:

1.  **Agile:** The focus on **constant evolution** and the need for **working code every two weeks** are hallmarks of Agile development's short cycles and frequent feedback loops.
    
2.  **Waterfall:** This scenario is a classic example of the Waterfall model, characterized by **unchanging requirements** and a **strict, sequential order** of execution.
    
3.  **Incremental:** The project is built by adding **separate, planned feature additions** in later releases, which is the core principle of the Incremental model.
    
4.  **Prototype:** Creating a **non-functional visual mock-up** to finalize a design demonstrates the Prototype approach, where an early model is built to clarify requirements.
    
5.  **Spiral:** The project's need for extensive **risk analysis** at every stage, especially due to a catastrophic failure risk, is the primary identifier of the Spiral model.
    
6.  **Iterative:** The description of **short, time-boxed cycles** that deliver an **improved and more refined version** of the software directly points to the Iterative model's core concept of refinement.
    
7.  **Incremental:** The key here is that **each module is developed and delivered** to the client as it is completed, allowing for early and piecemeal delivery.
    
8.  **Prototype:** The need to interact with a **working demo** to help finalize features and experience is the classic use case for the Prototype model.
    
9.  **Spiral:** The phrase **"mitigate risks before committing to development"** is the central principle of the Spiral model's risk-driven approach.
    
10.  **Waterfall:** The desire for a **rigid, step-by-step plan** for a well-understood project signifies a linear, non-overlapping approach characteristic of the Waterfall model.
     
11.  **Agile:** The need for **constant feedback** to quickly adapt and add features is a perfect fit for the Agile model's flexible and customer-centric methodology.
     
12.  **Prototype:** Building a **rough version** to get feedback on the overall concept before committing resources is the essence of the Prototype model.
     
13.  **Incremental:** New features being **added in phases** and each new release containing a new set of capabilities defines the Incremental model's strategy.
     
14.  **Iterative:** The process of **development-and-testing cycles** to add more functionality and **improve the product** over time is the defining feature of the Iterative model.
     
15.  **Spiral:** The mention of **risk management** and review before moving between phases directly points to the risk-driven nature of the Spiral model.
     
16.  **Incremental:** The strategy of releasing a product with core features first to meet a **tight deadline** and then delivering more features **incrementally** is a key characteristic of this model.
     
17.  **Agile:** Close collaboration, **daily check-ins**, and the need to **adapt to changing requirements** are all core principles of the Agile methodology.
     
18.  **Iterative:** Developing software in **multiple versions**, where each subsequent version is a more complete **refinement** of the previous one, is the definition of the Iterative model.
     
19.  **Prototype:** The client's **uncertainty about the final design** and the decision to build a **throwaway prototype** to explore options is a classic Prototype scenario.
     
20.  **Waterfall:** The presence of **stable, well-defined requirements** and a process that moves through **distinct stages** in a strict sequence is the foundation of the Waterfall model.
***
###  Q.23 Define term agile and write any four principles of agile manifesto (4 marks)

**Agile** is a flexible and collaborative **software development methodology** that emphasizes **iterative progress**, **customer feedback**, and **rapid delivery** of working software. It helps teams adapt to changing requirements and maintain continuous improvement throughout the project lifecycle.

 **Any Four Agile Principles:**

1.  **Customer satisfaction** is the highest priority through early and continuous software delivery.
    
2.  **Welcome changing requirements**, even late in development.
    
3.  **Deliver working software frequently**, with a preference for shorter timescales.

4.  **Face-to-face communication** is the most efficient and effective method of conveying information.

 **Example:**

A **food delivery app** team uses Agile to release small updates weekly, like adding new features or fixing bugs, based on user feedback.
  ***
### Q.24 Define following terms of agile model: 1. Sprint  2. Scrum  3. Daily Scrum  4. Sprint Backlog (each 2 marks)

 **1. Sprint:**

A **Sprint** is a short, fixed time-box (usually 1–4 weeks) where a specific portion of the project is developed, tested, and reviewed. It ends with a working product increment.

> **Example:** A mobile app team completes the “login and registration” feature in a 2-week Sprint.



**2. Scrum:**

**Scrum** is an **Agile framework** that breaks the project into small iterations (Sprints) with roles like Scrum Master, Product Owner, and Development Team collaborating to deliver value.

> **Example:** A software company uses Scrum to manage weekly progress and reviews for its e-commerce project.

**3. Daily Scrum:**

The **Daily Scrum** is a quick 15-minute meeting each day where team members share what they did yesterday, what they plan today, and any blockers.

> **Example:** A team member reports a bug that blocked yesterday’s task and asks for help during the daily stand-up.

 **4. Sprint Backlog:**
The **Sprint Backlog** is the to-do list for a single sprint.
It's a small checklist of tasks that the team promises to finish in a short period (usually 2-4 weeks). These tasks are chosen from the much bigger list of all project features.
> **Example:** The Sprint Backlog includes “profile update feature,” “settings UI,” and “unit testing for login module” for this week’s Sprint.
***
  
### Q.25 Draw and explain Scrum process of Agile model (6 marks)

The **Scrum process** is a part of Agile development. It helps teams build software in **short cycles** (called **Sprints**) that usually last **1 to 3 weeks**. Each Sprint delivers a **working product** and allows for regular feedback and improvement.
![image](.attachments/8668e038299b321801778cdd8962b88ca221e4b6.webp) 
 🌀 **Scrum Workflow Steps (Based on the Diagram):**
 
-   **Product Backlog**  
    A full list of features, updates, and fixes that the product needs. This list is made and managed by the **Product Owner**, and keeps changing as new ideas come up.
    
-   **Sprint Planning**  
    Before each Sprint starts, the team discusses and picks items from the Product Backlog that they will work on. Goals are set, and work is planned.
    
-   **Sprint Backlog**  
    A smaller, clear to-do list created from the planning meeting. It includes all tasks the team will finish during the Sprint.
    
-   **Sprint (1 to 3 weeks)**  
    The actual work period where the team builds the features, fixes bugs, and tests.  
    🔁 **Daily Scrum** – A short 15-minute daily meeting where team members quickly share progress, problems, and what they’ll do next.
    
-   **Potentially Shippable Product**  
    At the end of the Sprint, the team has a small working part of the product. It is ready to show or release if needed.
    
-   **Sprint Review**  
    The team shows what they built during the Sprint to the clients or stakeholders. They collect feedback and suggestions.
    
-   **Sprint Retrospective**  
    The team sits together and discusses what went well, what didn’t, and how to improve in the next Sprint.

***
### Q.26 Differentiate between SDLC models (any 2) (4/6 marks)
![image](.attachments/841defb3c7c40d4b7d71f5531037951fdf9ccb1b.png) 
***
# by PR7BZ (github.com/p7xckd/nf)
